---
id : 'test-programmers-4'
title: '[프로그래머스 | 택배 배달과 수거하기] Java'
date: '2025-01-16'
excerpt: '2023 KAKAO BLIND RECRUITMENT (2번 문제) [택배 배달과 수거하기] 문제풀이(정답 포함) 글입니다.'
type: 'test'
---

## 문제

<div class="markdown">
    <div class="img">
        <img src="/imgs/programmers4/programmers4_1.png" alt="programmers4_1 img" />
        <div class="explanation text-center">
            참고 자료
        </div>
    </div>
</div>
<br>

당신은 일렬로 나열된 n개의 집에 택배를 배달하려 합니다. 배달할 물건은 모두 크기가 같은 재활용 택배 상자에 담아 배달하며, 배달을 다니면서 빈 재활용 택배 상자들을 수거하려 합니다.<br>
배달할 택배들은 모두 재활용 택배 상자에 담겨서 물류창고에 보관되어 있고, i번째 집은 물류창고에서 거리 i만큼 떨어져 있습니다. 또한 i번째 집은 j번째 집과 거리 j - i만큼 떨어져 있습니다. (1 ≤ i ≤ j ≤ n)
트럭에는 재활용 택배 상자를 최대 cap개 실을 수 있습니다. 트럭은 배달할 재활용 택배 상자들을 실어 물류창고에서 출발해 각 집에 배달하면서, 빈 재활용 택배 상자들을 수거해 물류창고에 내립니다. 각 집마다 배달할 재활용 택배 상자의 개수와 수거할 빈 재활용 택배 상자의 개수를 알고 있을 때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 구하려 합니다. 각 집에 배달 및 수거할 때, 원하는 개수만큼 택배를 배달 및 수거할 수 있습니다.<br>
<br>
다음은 cap=4 일 때, 최소 거리로 이동하면서 5개의 집에 배달 및 수거하는 과정을 나타낸 예시입니다.<br>
<br>

**배달 및 수거할 재활용 택배 상자 개수**
||집#1|집#2|집#3|집#4|집#5|
|:-|:-|:-|:-|:-|:-|
|배달|1개|0개|3개|1개|2개|
|수거|0개|3개|0개|4개|0개|

<br>

**배달 및 수거 과정**
||집#1|집#2|집#3|집#4|집#5|설명|
|:-|:-|:-|:-|:-|:-|:-|
|남은 배달/수거|1/0|0/3|3/0|1/4|2/0|물류창고에서 택배 3개를 트럭에 실어 출발합니다.|
|남은 배달/수거|1/0|0/3|3/0|0/4|0/0|물류창고에서 5번째 집까지 이동하면서(거리 5) 4번째 집에 택배 1개를 배달하고, 5번째 집에 택배 2개를 배달합니다.|
|남은 배달/수거|1/0|0/3|3/0|0/0|0/0|5번째 집에서 물류창고까지 이동하면서(거리 5) 4번째 집에서 빈 택배 상자 4개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내리고 택배 4개를 트럭에 싣습니다.|
|남은 배달/수거|0/0|0/3|0/0|0/0|0/0|물류창고에서 3번째 집까지 이동하면서(거리 3) 1번째 집에 택배 1개를 배달하고, 3번째 집에 택배 3개를 배달합니다.|
|남은 배달/수거|0/0|0/0|0/0|0/0|0/0|3번째 집에서 물류창고까지 이동하면서(거리 3) 2번째 집에서 빈 택배 상자 3개를 수거한 후, 수거한 빈 택배 상자를 물류창고에 내립니다.|

<br>

16(=5+5+3+3)의 거리를 이동하면서 모든 배달 및 수거를 마쳤습니다. 같은 거리로 모든 배달 및 수거를 마치는 다른 방법이 있지만, 이보다 짧은 거리로 모든 배달 및 수거를 마치는 방법은 없습니다.<br>
트럭에 실을 수 있는 재활용 택배 상자의 최대 개수를 나타내는 정수 cap, 배달할 집의 개수를 나타내는 정수 n, 각 집에 배달할 재활용 택배 상자의 개수를 담은 1차원 정수 배열 deliveries와 각 집에서 수거할 빈 재활용 택배 상자의 개수를 담은 1차원 정수 배열 pickups가 매개변수로 주어집니다. 이때, 트럭 하나로 모든 배달과 수거를 마치고 물류창고까지 돌아올 수 있는 최소 이동 거리를 return 하도록 solution 함수를 완성해 주세요.<br>
<br>

***

### 제한사항

* 1 ≤ cap ≤ 50
* 1 ≤ n ≤ 100,000
* deliveries의 길이 = pickups의 길이 = n
    * deliveries[i]는 i+1번째 집에 배달할 재활용 택배 상자의 개수를 나타냅니다.
    * pickups[i]는 i+1번째 집에서 수거할 빈 재활용 택배 상자의 개수를 나타냅니다.
    * 0 ≤ deliveries의 원소 ≤ 50
    * 0 ≤ pickups의 원소 ≤ 50
    <br>
* 트럭의 초기 위치는 물류창고입니다.

<br>

***

## 입출력 예

|cap|n|deliveries|pickups|result|
|:-|:-|:-|:-|:-|
|4|5|[1, 0, 3, 1, 2]|[0, 3, 0, 4, 0]|16|
|2|7|[1, 0, 2, 0, 1, 0, 2]|[0, 2, 0, 1, 0, 2, 0]|30|

## 풀이 과정

우선적으로 생각한 방법은 0이 아닌 가장 먼 배달/수거가 이루어져야하는 집부터 최대로 많은 양을 배달하며 진행하는 방식이다. <br>
테스트 케이스 1번으로 설명하자면, 한번에 실을 수 있는 박스의 양은 4개니까 배달을 해야하는 가장 먼 집인 5번집부터 배달해야하는 갯수를 체크한다. <br>
5번집은 2개, 4번집은 1개 까지 배달을 하고, 3번집은 3개가 이루어져야 하기 때문에 1개만 배달을 하고 2개로 바꿔준다. <br>
똑같은 방법으로 수거를 해야하는 집 또한 갯수를 체크한다. <br>
5번집은 0개니까 지나가고, 4번집 4개 수거하면 최대치이기 때문에 나머지 집들은 지나간다. <br>
그 이후 배달한 최대치까지의 거리를 더한다. 이 때 배달하러 가는 거리 + 돌아오는 거리 를 더해야 하기 때문에, * 2 를 해준다. <br>
모든 집을 배달하면 배달한 거리를 return 해준다. <br>

~~~
class Solution {
    public long solution(int cap, int n, int[] deliveries, int[] pickups) {

        long answer = 0;
        int length = n - 1;

        // 배달 가야하는 거리가 0 이 되면 종료
        while (length != -1) {

            // 가야 할 거리 계산
            if (deliveries[length] == 0 && pickups[length] == 0) {
                length--;
                continue;
            }

            // 배달
            func(deliveries, cap, length);

            // 수거
            func(pickups, cap, length);

            // 이동한 총 거리 계산
            answer += (length + 1) * 2L;

        }

        return answer;

    }

    private void func(int[] arr, int cap, int length) {

        // 가장 먼 곳 부터 배달, 수거 작업
        for (int i = length; i >= 0; i--) {

            // 최대치만큼 작업
            if (cap == 0) {
                break;
            }

            // 남은 작업이 더이상 없을때까지 반복
            if (arr[i] != 0) {
                arr[i]--;
                cap--;
                i++;
            }

        }

    }
    
}
~~~